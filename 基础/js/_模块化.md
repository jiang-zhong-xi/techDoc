## CommonJS

#### 使用方法

给每个模块都暴露了require和module、export接口，module方法有个export属性指向暴露的export。

a.js

```javascript
module.export.name = '将'
```

b.js

```javascript
module.export.say = function(name) {
	console.log(name)
}
```

index.js

```javascript
var a = require('./a.js')
var b = require('./b.js')
console.log(b.say(a.name)) // 姜
```

#### 运行机制

首先是执行node index.js，此时会创建一个module，该module是入口module，只有这个module执行require.main === module是true，然后执行到require('./a.js')会经历以下过程。

1. 初始化。

   ```javascript
   Module._load = function(request, parent, isMain) {
     // 将a.js解析完绝对路径
     var filename = Module._resolveFilename(request, parent, isMain);
     // 如果已经缓存了直接返回模块的exports对象
     var cachedModule = Module._cache[filename];
     if (cachedModule) {
       updateChildren(parent, cachedModule, true);
       return cachedModule.exports;
     }
     // 检查路径是否为nodeJs本身模块
     if (NativeModule.nonInternalExists(filename)) {
       debug('load native module %s', request);
       return NativeModule.require(filename);
     }
   	
     // 生成新module，module是一个双向链表其中的parent和children指向父依赖和子依赖，这样包括所有模块
     var module = new Module(filename, parent);
   
     if (isMain) { // 入口模块
       process.mainModule = module;
       module.id = '.';
     }
     // 先存入缓存，如果加载失败再删除
     Module._cache[filename] = module;
     // 试着去加载模块
     tryModuleLoad(module, filename);
   
     return module.exports;
   };
   ```

   首先是将相对路径转为绝对路径，然后检查是否缓存了，如果缓存了直接返回模块的exports，如果是nodejs本身模块就通过NativeModule返回，否则新建Module对象。

2. 读取，编译。

   ```javascript
   Module.prototype.load = function(filename) {
     this.filename = filename;
      // 解析文件目录的node_modules和上级目录的node_modules 
     this.paths = Module._nodeModulePaths(path.dirname(filename));
     // 文件扩展名
     var extension = findLongestRegisteredExtension(filename);
     // 加载、解析文件
     Module._extensions[extension](this, filename);
     this.loaded = true;
   };
   ```

   this.paths存储的目录是按filename失败时的寻找路径，不建议利用，消耗时间。

   ```javascript
   Module._extensions['.js'] = function(module, filename) {
     var content = fs.readFileSync(filename, 'utf8'); // 加载
     module._compile(stripBOM(content), filename); // 解析
   };
   ```

   ```javascript
   Module.prototype._compile = function(content, filename) {
     var require = makeRequireFunction(this);
     // compiledWrapper是由content字符串生成的函数，调用的是C++内部函数
     result = compiledWrapper.call(this.exports, this.exports, require, this,
                                     filename, dirname);
     return result;
   };
   ```
```
   
   makeRequireFunction将module.require赋值给require，而exports，require等作为入参传入compiledWrapper，执行compiledWrapper，将a.js中export的值（如果是表达式则求值）赋值给Module.exports，然后将module.exports赋值给index.js的b变量，b变量就是一个对象，如果export的属性中包含方法属性，就形成了闭包。
   
   见如下实例：
   
   ```javascript
   // b.js
   var age = 3
   exports.age = age
   exports.grow = function() {
   	age++
   }
   
   // index.js
   var b = require('./b.js')
   console.log(b.age) // 3
   b.grow() // age++后变成了4，但是module.exports是3，这是基本类型不能改变了，可以通过一个函数去访问age，见下例
   console.log(b.age)
   
   /*********************************修改后**********************************/
   // b.js
   var age = 3
   exports.getAge = funtion(){ return age }
   exports.grow = function() {
   	age++
   }
   // index.js
   var b = require('./b.js')
   console.log(b.getAge()) // 3
   b.grow() 
   console.log(b.getAge()) // 4
```

   

#### 循环依赖

   ```javascript
   // a.js
   exports.x = 1
   console.log('a.js', require('./b.js').y)
   exports.x = 2
   ```

   ```javascript
   // b.js
   exports.y = 3
   console.log('b.js', require('./a.js').x)
   exports.y = 4
   ```

   ```javascript
   // index.js
   var a = require('./a.js')
   console.log(a.x)
   ```

   结果：

   	b.js 1

   	a.js 4

   	2 

   表明b.js加载a.js的后，只执行了console.log('a.js', require('./b.js').x)的代码，这是由于CommonJs同步加载导致的。

#### 总结

commonJS实现的关键是node给入口模块暴露了module和export、require（require会传给子module）接口。require方法会加载执行请求的模块，并通过module.exports返回，另外Module.cache做了全局缓存，提高了性能。

## ES6 module

#### 静态优化

代码在编译时就确定了模块的依赖关系，比CommonJS的效率高。

#### 严格模式

自动采用严格模式：

- 不能使用未声明的变量

  ```javascript
   "use strict"
    yy = 2 // Uncaught ReferenceError: yy is not defined
  ```

- 函数参数不能重名

  ```javascript
  function t(p, p) {
  	'use strict' // Uncaught SyntaxError: Duplicate parameter name not allowed in this context
  }
  ```

- 不能使用with语句

- 不能对只读属性赋值，否则报错

- 不能使用前缀0表示八进制

- 不能删除变量，只能删除可删除的对象属性

- 不能使用arguments.caller、arguments.callee、fn.caller、fn.arguments

#### export

export有三种使用方式，其中默认导出和对象导出导出的都是变量的值，命名导出导出的是声明语句

1. 默认导出

   ```javascript
   var a = 1
   export default a
   
   import b from '../*' //import * as b from '../*'
   ```

   默认导出一个模块只能有一个，导入时可以按自己需求命令。

2. 命名导出

   ```javascript
   export var a = 1
   
   import {a} from '../' // import * as b from '../' b.a === 1
   ```

   命名导出可以有多个，但是导入名必须和导出名一致，但是可以通过as重命名。

3. 对象导出

   ```javascript
   var a = 1, b = 2;
   export {a, b}
   
   import {a, b} from '../*' // import * as obj from '../*' obj.a === 1 obj.b === 2
   ```

   对象导出也可以有多个。

#### 动态加载

提供了import函数，基本上和commonJS的require一样，import是异步加载，返回的是一个promise

```
import('../*')
.then((module) => {})
```

#### 循环依赖

不同于commonJs，ES6 module的模块加载发生在静态分析阶段，所以循环依赖得到的值是undefined，过程看下面的机制。

#### 机制

我们知道模块化为我们写代码提供很大的方便，我们可以专注于写某一个模块，另外还可以通过export、import去和其他模块沟通，那么module到底是怎样的执行过程呢？

1. 构建module record

   a. 查找并下载模块，通过import寻找所有依赖然后异步的下载模块对应的脚本并构建依赖图。

   b. 解析为模块，把脚本内容解析为module record，模块类包括语法树（ast）、导入的模块等，然后建立请求地址和模块类的映射关系，作为缓存，下一次时可以直接使用。module record的的依赖构成了依赖图。

2. 实例模块类

   根据依赖图深度优先的遍历模块类，为模块类创建对应的模块上下文表，模块上下文表管理变量名和对应值的地址，如果是export的变量则标识出来，然后把对应的import和export都指向这个值对应的地址。

3. 执行代码

   执行代码，将所有变量赋值，也就是该步骤之前所有变量都没有初始化，所以循环依赖得到了undefined。

另外：es module export的变量的值是实时更新的，即对于普通类型的值在模块内或者模块外都能更新值，区别于commonJs。

机制原文地址（https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/）待翻译。。。